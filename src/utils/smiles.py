from time import time
import numpy as np


def canon_single_smile(smi):
    """ ... """
    from rdkit import Chem
    try:
        # canon = Chem.MolFromSmiles(smi)
        # if canon is not None:
        #     return Chem.MolToSmiles(canon, canonical=True)
        # else:
        #     print(smi)
        # (ap)
        mol = Chem.MolFromSmiles(smi)
        can_smi = Chem.MolToSmiles(mol, canonical=True)
    except:
        # print('error', smi)
        print(f'Error in smile: {smi}')
        can_smi = np.nan
    return can_smi


def canon_df(df, smi_name='smiles'):
    """ Canonicalize the smiles sting in column name smi_name. """
    smi_vec = []
    t0 = time()
    # for i, s in enumerate(smi_vec[smi_name]):
    for i, smi in enumerate(df[smi_name].values):
        if i%50000==0:
            print('{}: {:.2f} sec'.format(i, time()-t0))
            # t0 = time()
        can_smi = canon_single_smile( smi )
        smi_vec.append( can_smi ) # TODO: consider return this, instead of modifying df
        # df.loc[i, 'smiles'] = can_smi
        
    df.loc[:, 'smiles'] = smi_vec
    return df


def smile_to_fps_single(smi, radius):
    """ Convert single SMILES into Morgan fingerprints.
    From www.rdkit.org/docs/GettingStartedInPython.html#morgan-fingerprints-circular-fingerprints:
    When comparing the ECFP/FCFP FPs and the Morgan FPs generated by the RDKit, remember that the
    4 in ECFP4 corresponds to the diameter of the atom environments considered, while the Morgan FPs
    take a radius parameter. So when radius=2, this is roughly equivalent to ECFP4 and FCFP4."""
    # From Xuefeng:
    # nbits = 1024
    # canonical_smile=pybel.readstring("smi", row["smiles"]).write("can").strip()
    # m1 = Chem.MolFromSmiles(canonical_smile)
    # ecfp4 = AllChem.GetMorganFingerprintAsBitVect(m1, 2, nBits=nbits)
    # ecfp4_fingers = np.array(ecfp4).tolist()

    # From stackoverflow
    # stackoverflow.com/questions/54809506/how-can-i-compute-a-count-morgan-fingerprint-as-numpy-array

    from rdkit.Chem import AllChem, DataStructs
    nbits = 1024
    mol = Chem.MolFromSmiles( smi )
    fp = AllChem.GetMorganFingerprintAsBitVect(mol=mol, radius=radius, nBits=nbits)

    # method 1
    # arr = np.zeros((0, ), dtype=np.int8)
    # DataStructs.ConvertToNumpyArray(fp, arr)  # convert in-place

    # method 2
    fp_arr = np.array(fp).tolist()
    return fp_arr


def smiles_to_fps(smi_vec, smi_name='smiles'):
    """ Canonicalize a smiles vector and generate df of FPs. """
    smi_vec = []
    t0 = time()
    # for i, s in enumerate(smi_vec[smi_name]):
    for i, smi in enumerate(df[smi_name].values):
        if i%50000==0:
            print('{}: {:.2f} sec'.format(i, time()-t0))
            # t0 = time()
        can_smi = canon_single_smile( smi )
        smi_vec.append( can_smi ) # TODO: consider return this, instead of modifying df
        # df.loc[i, 'smiles'] = can_smi
        
    df.loc[:, 'smiles'] = smi_vec
    return df


# def modred_single_smile(smi):
#     """ ... """
#     # from rdkit import Chem
#     # from mordred import Calculator, descriptors
#     try:
#         mol = Chem.MolFromSmiles(smi)
#         # can_smi = Chem.MolToSmiles(canon, canonical=True)
#     except:
#         # print('error', smi)
#         print(f'Error: smiles={smi}')
#         mol = np.nan
#     return mol


# def smi_to_mordred(df, smi_name='smiles'):
#     """ ... """    
#     from rdkit import Chem
#     from mordred import Calculator, descriptors
#     t0 = time()
#     # create descriptor calculator with all descriptors
#     calc = Calculator(descriptors, ignore_3D=True)
#     # print( len(calc.descriptors) )
#     # print( len(Calculator(descriptors, ignore_3D=True, version="1.0.0")) )
    
#     mol_vec = []
#     for i, s in enumerate(df[smi_name]):
#         if i%50000==0:
#             print('{}: {:.2f} sec'.format(i, time()-t0))
#             t0 = time()
#         df.loc[i, 'smiles'] = canon_single_smile(s)
        
#         mol = canon_single_smile(s)
#         df.loc[i, 'smiles'] = can_smi
#     df = calc.pandas(mols)
#     return df

